use std::str::FromStr;
use crate::{
    ast::{RawExpr, RawIdent, BinaryOp},
    types::Type,
    values::Val,
};

grammar();

pub Uplp = Expr;

Expr: Box<RawExpr> = {
    Abstraction => <>,
    Application => <>,
}

Abstraction: Box<RawExpr> = {
    // function definition
    "|" <Ident> ":" <Type> "|" <Expr> => Box::new(RawExpr::Lambda(<>)),
    // let bindings
    "let" <Ident> "=" <Expr> "in" <Expr> => Box::new(RawExpr::Let(<>)),
}

// n-ary application, where n currently is between 0 and 2
Application: Box<RawExpr> = {
    // either an infix binary op or a terminal.
    // i don't love that terminal is nested here, but don't currently have
    // a better idea.
    InfixBinaryOp => <>,
    // function application
    <Application> <InfixBinaryOp> => Box::new(RawExpr::App(<>)),
}

// Used to encode precedence levels for infix binary ops.
InfixOpTier<Op, NextTier>: Box<RawExpr> = {
    InfixOpTier<Op, NextTier> Op NextTier => Box::new(RawExpr::Op(<>)),
    NextTier,
};

InfixBinaryOp = InfixOpTier<InfixOp1, InfixBinaryOpTier2>;
InfixBinaryOpTier2 = InfixOpTier<InfixOp2, Terminal>;

InfixOp1: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
};

InfixOp2: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
};

Terminal: Box<RawExpr> = {
    Num => Box::new(RawExpr::Literal(Val::Num(<>))),
    "()" => Box::new(RawExpr::Literal(Val::Unit)),
    <Ident> => Box::new(RawExpr::Var(<>)),
    "(" <Expr> ")"
};

Type: Type = {
    "Num" => Type::Num,
    "Unit" => Type::Unit,
};

Ident: RawIdent = {
    r"_?[a-zA-Z][a-zA-Z0-9_-]*" => <>.into()
}

Num: f64 = {
    r"-?[0-9]+(?:\.[0-9]+)?" => f64::from_str(<>).unwrap(),
}

match {
    // skip whitespace by default
    r"\s*" => { },
    // skip single-line comments beginning with "--"
    r"--[^\n\r]*[\n\r]*" => { },
    _
}